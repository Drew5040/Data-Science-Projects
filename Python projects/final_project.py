# FINAL PROJECT
# TITLE: Using Modern Portfolio Theory and Monte Carlo Simulation for Portfolio Optimization
# Andrew O'Drain
# CIS 1051
# Professor: Rosen, Andrew
# TA: Joanne A. Nichols
# Section: 007
############################
############################


import plotly.express as px
import pandas as pd
import yfinance as yf
import numpy as np


# Pulls in crypto price history
def api_call(string):
    data = yf.Ticker(string + '-USD').history(period='max', interval='1wk').reset_index()[['Date', 'Open']]
    data = data.rename(columns={'Open': string})
    return data


# Pull in the time series data for each coin we want in our portfolio

btc = api_call('BTC')
link = api_call('LINK')
eth = api_call('ETH')
#print()
#print("Example of data that api_call function pull in from Yahoo finance API")
#print()
#print(btc)

# Merge all data into 1 larger data frame
# Merge by the date column

final_df = pd.merge(btc, link, on='Date', how='inner')
final_df = pd.merge(final_df, eth, on='Date', how='inner')

# reset the index column for time series data
# Makes 'dates' a real index column

final_df = final_df.set_index('Date')
#print()
#print("What our final Data frame looks like before calculations")
#print()
#print(final_df)

# Calculates the chosen period return for each coin in dataframe

df_returns = final_df.pct_change()
#print()
#print('Data after applying percent change formula')
#print()
#print(df_returns)

# Historical average of each crypto return in dataframe
# Needed for calculating each portfolio return

df_avg_returns = df_returns.mean()
#print()
#print('Mean of each column')
#print()
#print(df_avg_returns)

# Calculate the historical covariance matrix of returns that includes each crypto in dataframe

df_cov_matrix = df_returns.cov()
#print()
# print("Covariance Matrix")
# print()
# print(df_cov_matrix)


# Column headers

crypto = ['BTC', 'LINK', 'ETH']

num_simulations = 100000

# Need a container to store simulation results in
# Create a numpy array of zeroes using a tuple
#
# print()
# print("NumPy array that is dynamic")
# print()
simulation_results = np.zeros((4 + len(crypto) - 1, num_simulations))
# print(simulation_results)

# SIMULATE PORTFOLIOS
# Each iteration of the loop is going to generate 1 simulated portfolio
# which will then be stored in the zeros array

for i in range(num_simulations):

    # create a weights array
    # to hold 'n' random numbers depending on how many crytos we want in our final portfolio
    # They will be the random weightings of BTC and LINK and ETH
    random_weights = np.array(np.random.random(3))

    # divide each value in the array by the sum
    # To get the percentage weighting of each asset in the portfolio
    portfolio_random_weights = random_weights / np.sum(random_weights)

    # calculate each portfolios returns
    portfolio_returns = np.sum(df_avg_returns * portfolio_random_weights)

    # calculate the portfolio standard deviation using linear algebra
    portfolio_standard_deviation = np.sqrt(
        np.dot(portfolio_random_weights.T, np.dot(df_cov_matrix, portfolio_random_weights)))

    # Populate our simulation results
    # index into our zeroes array
    simulation_results[0, i] = portfolio_returns
    simulation_results[1, i] = portfolio_standard_deviation

    # sharp ratio
    simulation_results[2, i] = simulation_results[0, i] / simulation_results[1, i]

    # To fill the remaining values use a for loop to iterate through
    # weights variable. this fills rows 4 to 6 to be displayed as the weights
    # used for the individual portfolio
    # print()
    # print('Populate the last three empty spots of NumPy zeros array')
    for j in range(len(portfolio_random_weights)):
        simulation_results[j + 3, i] = portfolio_random_weights[j]
        # print(simulation_results[j + 3, i])
# print()
# print('Example of random weights generated by NumPy')
# print(random_weights)
# print()
# print('Example of one simulated portfolio in original form. When full simulation is run we will have 500,000 of these')
# print()
# print(simulation_results)
# Turn our transposed NumPy array into a pandas dataframe to begin visualizing
result_plot = pd.DataFrame(simulation_results.T, columns=["AVG-RET", "STDV", "SHARPE", crypto[0], crypto[1], crypto[2]])
# print()
# print('Example of the transpose of one simulated portfolio')
# print()
# print(result_plot)

# Turn the dataframe into a plotly express scatterplot. The best feature here is creating the hover data
# Hover data creates a pop-up box on the scatterplot to show the results of each portfolio
scatter_plot = px.scatter(result_plot, x='STDV', y='AVG-RET', color='SHARPE', template="plotly_dark",
                 hover_data=[crypto[0], crypto[1], crypto[2]])


# Update the X and Y Axis names on scatterplot
scatter_plot.update_xaxes(title_text="Volatility", title_font_size=20)
scatter_plot.update_yaxes(title_text="Average Returns", title_font_size=20)

# Display the results on CPU
scatter_plot.show()
